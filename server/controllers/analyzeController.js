import { OpenAI } from 'openai';
import axios from 'axios';
import { Octokit } from '@octokit/rest';
import dotenv from 'dotenv';

dotenv.config();

// Debug environment variables
console.log('Environment check in analyzeController:');
console.log('OPENAI_API_KEY exists:', !!process.env.OPENAI_API_KEY);
console.log('OPENAI_API_KEY length:', process.env.OPENAI_API_KEY?.length);
console.log('PAT_TOKEN exists:', !!process.env.PAT_TOKEN);
console.log('PAT_TOKEN length:', process.env.PAT_TOKEN?.length);
console.log('NODE_ENV:', process.env.NODE_ENV);

// Initialize OpenAI client only if API key exists
let openai;
if (process.env.OPENAI_API_KEY) {
    try {
        openai = new OpenAI({
            apiKey: process.env.OPENAI_API_KEY
        });
    } catch (error) {
        console.error('Error initializing OpenAI:', error.message);
    }
}

export const analyze = async (req, res) => {
    try {
        // Check for required environment variables
        if (!process.env.PAT_TOKEN) {
            return res.status(500).json({
                error: 'Configuration Error',
                message: 'PAT_TOKEN environment variable is not set. Please configure it in your environment settings.',
                details: 'This token is required for GitHub API access.'
            });
        }

        if (!openai) {
            return res.status(500).json({
                error: 'Configuration Error',
                message: 'OpenAI client not initialized. Please check your OPENAI_API_KEY environment variable.',
                details: 'This key is required for code analysis.'
            });
        }

        const { repo, lang } = req.body;
        
        if (!repo || !lang) {
            return res.status(400).json({
                error: 'Missing required fields',
                details: { repo, lang }
            });
        }

        console.log('Starting analysis for:', { repo, lang });

        // Get repository files
        const files = await getRepoFiles(repo);
        console.log('Found files:', files.map(f => f.path));
        
        // Analyze code using OpenAI
        const analysis = await analyzeWithAI(files, lang);
        console.log('Analysis completed:', analysis);
        
        // Generate fixes
        const fixes = await generateFixes(analysis, files, lang);
        console.log('Fixes generated:', fixes.length);

        // If we have fixes, create a PR
        if (fixes.length > 0) {
            const [owner, repoName] = repo.split('/');
            const octokit = new Octokit({
                auth: process.env.PAT_TOKEN
            });

            // Create a new branch for fixes
            const defaultBranch = 'main';
            const fixBranchName = `fix/${Date.now()}`;

            // Get the latest commit SHA from the default branch
            const { data: refData } = await octokit.git.getRef({
                owner,
                repo: repoName,
                ref: `heads/${defaultBranch}`
            });
            const latestCommitSha = refData.object.sha;

            // Create a new branch
            await octokit.git.createRef({
                owner,
                repo: repoName,
                ref: `refs/heads/${fixBranchName}`,
                sha: latestCommitSha
            });

            // Apply fixes one by one
            for (const fix of fixes) {
                const { file, fixedContent, issue } = fix;
                
                // Get the current file content
                const { data: fileData } = await octokit.repos.getContent({
                    owner,
                    repo: repoName,
                    path: file,
                    ref: fixBranchName
                });

                // Update the file with fixed content
                await octokit.repos.createOrUpdateFileContents({
                    owner,
                    repo: repoName,
                    path: file,
                    message: `fix: ${issue.description}`,
                    content: Buffer.from(fixedContent).toString('base64'),
                    branch: fixBranchName,
                    sha: fileData.sha
                });
            }

            // Create pull request
            await octokit.pulls.create({
                owner,
                repo: repoName,
                title: '[Scriptocol] Automated fixes',
                body: `This PR contains automated fixes generated by Scriptocol.

### Changes Made:
${fixes.map(fix => `- ${fix.issue.description}`).join('\n')}

Please review the changes carefully.`,
                head: fixBranchName,
                base: defaultBranch,
                labels: ['automated-pr', 'scriptocol']
            });
        }
        
        return res.status(200).json({
            message: 'Analysis completed',
            analysis,
            fixes
        });
    } catch (error) {
        console.error('Error in analyze:', error);
        return res.status(500).json({
            error: 'Internal server error',
            details: error.message
        });
    }
};

async function getRepoFiles(repo) {
    try {
        // Ensure repo is in the format owner/repo
        if (!repo.includes('/')) {
            throw new Error('Repository must be in the format owner/repo');
        }

        console.log('Fetching contents for repository:', repo);
        const response = await axios.get(`https://api.github.com/repos/${repo}/contents`, {
            headers: {
                Authorization: `Bearer ${process.env.PAT_TOKEN}`,
                Accept: 'application/vnd.github.v3+json'
            }
        });
        
        console.log('Found files:', response.data.map(file => file.name));
        
        const files = [];
        for (const item of response.data) {
            if (item.type === 'file') {
                try {
                    const content = await axios.get(item.download_url);
                    files.push({
                        name: item.name,
                        path: item.path,
                        content: content.data
                    });
                } catch (error) {
                    console.error(`Error fetching content for ${item.path}:`, error.message);
                }
            } else if (item.type === 'dir') {
                // Recursively get contents of directories
                const dirFiles = await getDirectoryContents(repo, item.path);
                files.push(...dirFiles);
            }
        }
        
        return files;
    } catch (error) {
        console.error('Error getting repo files:', error);
        throw error;
    }
}

async function getDirectoryContents(repo, path) {
    try {
        const response = await axios.get(`https://api.github.com/repos/${repo}/contents/${path}`, {
            headers: {
                Authorization: `Bearer ${process.env.PAT_TOKEN}`,
                Accept: 'application/vnd.github.v3+json'
            }
        });

        const files = [];
        for (const item of response.data) {
            if (item.type === 'file') {
                try {
                    const content = await axios.get(item.download_url);
                    files.push({
                        name: item.name,
                        path: item.path,
                        content: content.data
                    });
                } catch (error) {
                    console.error(`Error fetching content for ${item.path}:`, error.message);
                }
            } else if (item.type === 'dir') {
                // Recursively get contents of subdirectories
                const dirFiles = await getDirectoryContents(repo, item.path);
                files.push(...dirFiles);
            }
        }
        return files;
    } catch (error) {
        console.error(`Error getting contents for directory ${path}:`, error);
        return [];
    }
}

async function analyzeWithAI(files, lang) {
    try {
        const fileContents = files.map(file => `File: ${file.path}\n\`\`\`\n${file.content}\n\`\`\``).join('\n\n');
        
        const prompt = `Analyze the following ${lang} codebase for potential issues and improvements:

${fileContents}

Please identify:
1. Code quality issues
2. Potential bugs
3. Performance improvements
4. Security concerns
5. Best practice violations

Format your response as JSON with the following structure:
{
    "issues": [
        {
            "type": "bug|quality|performance|security|bestPractice",
            "severity": "low|medium|high",
            "description": "Detailed description of the issue",
            "file": "path/to/file",
            "line": "line number or range",
            "suggestion": "Suggested fix or improvement"
        }
    ]
}`;

        const completion = await openai.chat.completions.create({
            model: "gpt-4-turbo-preview",
            messages: [
                {
                    role: "system",
                    content: "You are a code analysis expert. Analyze the code and provide detailed issues and suggestions in JSON format."
                },
                {
                    role: "user",
                    content: prompt
                }
            ],
            temperature: 0.7,
            max_tokens: 4000
        });

        const response = completion.choices[0].message.content;
        console.log('OpenAI response:', response);
        
        try {
            const analysis = JSON.parse(response);
            return analysis;
        } catch (error) {
            console.error('Error parsing OpenAI response:', error);
            return { issues: [] };
        }
    } catch (error) {
        console.error('Error in analyzeWithAI:', error);
        return { issues: [] };
    }
}

async function generateFixes(analysis, files, lang) {
    try {
        if (!analysis.issues || analysis.issues.length === 0) {
            console.log('No issues found in analysis');
            return [];
        }

        const fixes = [];
        for (const issue of analysis.issues) {
            try {
                const file = files.find(f => f.path === issue.file);
                if (!file) {
                    console.log(`File not found: ${issue.file}`);
                    continue;
                }

                const prompt = `Fix the following issue in the ${lang} code:

File: ${file.path}
Issue: ${issue.description}
Suggestion: ${issue.suggestion}

Current code:
\`\`\`
${file.content}
\`\`\`

Please provide the fixed code that addresses this issue. Return only the fixed code without any explanations.`;

                const completion = await openai.chat.completions.create({
                    model: "gpt-4-turbo-preview",
                    messages: [
                        {
                            role: "system",
                            content: "You are a code fixing expert. Provide only the fixed code without any explanations."
                        },
                        {
                            role: "user",
                            content: prompt
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 2000
                });

                const fixedContent = completion.choices[0].message.content.trim();
                fixes.push({
                    file: issue.file,
                    fixedContent,
                    issue
                });
            } catch (error) {
                console.error(`Error generating fix for issue in ${issue.file}:`, error);
            }
        }

        console.log(`Generated ${fixes.length} fixes`);
        return fixes;
    } catch (error) {
        console.error('Error in generateFixes:', error);
        return [];
    }
}
