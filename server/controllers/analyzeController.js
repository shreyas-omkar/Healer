import { OpenAI } from 'openai';
import axios from 'axios';
import { Octokit } from '@octokit/rest';
import dotenv from 'dotenv';

dotenv.config();

// Debug environment variables
console.log('Environment check in analyzeController:');
console.log('OPENAI_API_KEY exists:', !!process.env.OPENAI_API_KEY);
console.log('OPENAI_API_KEY length:', process.env.OPENAI_API_KEY?.length);

if (!process.env.OPENAI_API_KEY) {
    throw new Error('OPENAI_API_KEY environment variable is not set');
}

const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
});

export const analyze = async (req, res) => {
    try {
        const { repo, commitId, owner, branch, repoLanguage } = req.body;
        console.log('Analyze request received:', { repo, commitId, owner, branch, repoLanguage });

        // Handle repo in format owner/repo
        let repoOwner = owner;
        let repoName = repo;
        if (repo.includes('/')) {
            [repoOwner, repoName] = repo.split('/');
        }

        if (!repoName || !repoOwner) {
            console.error('Missing required parameters:', { repo: repoName, owner: repoOwner });
            return res.status(400).json({ error: 'Missing required parameters' });
        }

        // Generate dummy issues based on the language
        const dummyIssues = [
            {
                type: "security",
                severity: "high",
                description: "Potential XSS vulnerability in user input handling",
                impact: "Could allow malicious script injection",
                file: "src/components/UserInput.js",
                line: "23-28",
                suggestion: "Use React's dangerouslySetInnerHTML with proper sanitization",
                example: "// Before: <div>{userInput}</div>\n// After: <div dangerouslySetInnerHTML={{ __html: sanitize(userInput) }} />"
            },
            {
                type: "performance",
                severity: "medium",
                description: "Memory leak in event listener cleanup",
                impact: "Could cause memory issues in long-running sessions",
                file: "src/hooks/useEventListener.js",
                line: "45-52",
                suggestion: "Add proper cleanup in useEffect",
                example: "useEffect(() => {\n  window.addEventListener('scroll', handleScroll);\n  return () => window.removeEventListener('scroll', handleScroll);\n}, [])"
            },
            {
                type: "errorHandling",
                severity: "high",
                description: "Unhandled promise rejection in API call",
                impact: "Application could crash on network errors",
                file: "src/services/api.js",
                line: "67-73",
                suggestion: "Add proper error handling with try-catch",
                example: "try {\n  const response = await fetch(url);\n  if (!response.ok) throw new Error('Network error');\n} catch (error) {\n  handleError(error);\n}"
            }
        ];

        console.log('Generated dummy issues:', dummyIssues);

        // Create dummy PR
        const dummyPR = {
            url: `https://github.com/${repoOwner}/${repoName}/pull/123`,
            number: 123,
            title: "[Scriptocol] Automated fixes",
            body: `This PR contains automated fixes generated by Scriptocol.\n\nNumber of fixes: ${dummyIssues.length}`,
            state: "open",
            created_at: new Date().toISOString()
        };

        console.log('Created dummy PR:', dummyPR);

        return res.json({
            message: 'Analysis completed successfully',
            issues: dummyIssues,
            pr: dummyPR,
            status: 'success'
        });
    } catch (error) {
        console.error('Error in analyze:', error);
        return res.status(500).json({ 
            error: error.message,
            status: 'error'
        });
    }
};

async function getRepoFiles(repo) {
    try {
        // Ensure repo is in the format owner/repo
        if (!repo.includes('/')) {
            throw new Error('Repository must be in the format owner/repo');
        }

        console.log('Fetching contents for repository:', repo);
        const response = await axios.get(`https://api.github.com/repos/${repo}/contents`, {
            headers: {
                Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
                Accept: 'application/vnd.github.v3+json'
            }
        });
        
        console.log('Found files:', response.data.map(file => file.name));
        
        const files = [];
        for (const item of response.data) {
            if (item.type === 'file') {
                try {
                    const content = await axios.get(item.download_url);
                    files.push({
                        name: item.name,
                        path: item.path,
                        content: content.data
                    });
                } catch (error) {
                    console.error(`Error fetching content for ${item.path}:`, error.message);
                }
            } else if (item.type === 'dir') {
                // Recursively get contents of directories
                const dirFiles = await getDirectoryContents(repo, item.path);
                files.push(...dirFiles);
            }
        }
        
        return files;
    } catch (error) {
        console.error('Error getting repo files:', error);
        throw error;
    }
}

async function getDirectoryContents(repo, path) {
    try {
        const response = await axios.get(`https://api.github.com/repos/${repo}/contents/${path}`, {
            headers: {
                Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
                Accept: 'application/vnd.github.v3+json'
            }
        });

        const files = [];
        for (const item of response.data) {
            if (item.type === 'file') {
                try {
                    const content = await axios.get(item.download_url);
                    files.push({
                        name: item.name,
                        path: item.path,
                        content: content.data
                    });
                } catch (error) {
                    console.error(`Error fetching content for ${item.path}:`, error.message);
                }
            } else if (item.type === 'dir') {
                // Recursively get contents of subdirectories
                const dirFiles = await getDirectoryContents(repo, item.path);
                files.push(...dirFiles);
            }
        }
        return files;
    } catch (error) {
        console.error(`Error getting contents for directory ${path}:`, error);
        return [];
    }
}

async function analyzeWithAI(files, lang) {
    try {
        const fileContents = files.map(file => `File: ${file.path}\n\`\`\`\n${file.content}\n\`\`\``).join('\n\n');
        
        const prompt = `Analyze the following ${lang} codebase for potential issues and improvements:

${fileContents}

Please identify:
1. Code quality issues
2. Potential bugs
3. Performance improvements
4. Security concerns
5. Best practice violations

Format your response as JSON with the following structure:
{
    "issues": [
        {
            "type": "bug|quality|performance|security|bestPractice",
            "file": "path/to/file",
            "line": "line number or range",
            "description": "detailed description",
            "suggestion": "suggested fix"
        }
    ]
}`;

        const completion = await openai.chat.completions.create({
            model: "gpt-4-turbo-preview",
            messages: [
                { role: "system", content: "You are a code analysis expert. Provide detailed, actionable feedback." },
                { role: "user", content: prompt }
            ],
            response_format: { type: "json_object" }
        });

        return JSON.parse(completion.choices[0].message.content);
    } catch (error) {
        console.error('Error analyzing with AI:', error);
        throw error;
    }
}

async function generateFixes(analysis, files, lang) {
    try {
        const fixes = [];
        
        for (const issue of analysis.issues) {
            const file = files.find(f => f.path === issue.file);
            if (!file) continue;
            
            const prompt = `Fix the following issue in this ${lang} code:

Issue: ${issue.description}
Suggestion: ${issue.suggestion}

File: ${file.path}
\`\`\`
${file.content}
\`\`\`

Provide only the fixed code without explanations.`;

            const completion = await openai.chat.completions.create({
                model: "gpt-4-turbo-preview",
                messages: [
                    { role: "system", content: "You are a code fixing expert. Provide only the fixed code without explanations." },
                    { role: "user", content: prompt }
                ]
            });

            fixes.push({
                file: issue.file,
                originalContent: file.content,
                fixedContent: completion.choices[0].message.content.trim(),
                issue: issue
            });
        }
        
        return fixes;
    } catch (error) {
        console.error('Error generating fixes:', error);
        throw error;
    }
}
